        when 1923, 1924, 1926, 1932, 1934, 1935, 1940, 1942, 1943, 1946, 1948, 1951, 1953, 1954,
                   1956, 1959, 1961, 1962, 1964, 1965, 1967, 1973, 1975, 1981, 1983, 1986, 1994, 2002,
                   2005, 2008, 2013, 2016, 2021, 2029, 2043  ; 1
        when 1920, 1922, 1925, 1927, 1930, 1931, 1933, 1938, 1939, 1941, 1949, 1950, 1957, 1958,
                   1966, 1969, 1972, 1977, 1980, 1984, 1985, 1988, 1991, 1992, 1999, 2000, 2007, 2010,
                   2011, 2018, 2019, 2024, 2026, 2027, 2030, 2032, 2035, 2037, 2038, 2040, 2041, 2045,
                   2046, 2048, 2049  ; 2
        when 1928, 1936, 1944, 1947, 1952, 1955, 1960, 1963, 1968, 1971, 1974, 1976, 1979, 1982,
                   1987, 1990, 1993, 1995, 1996, 1998, 2001, 2003, 2004, 2006, 2009, 2014, 2015, 2017,
                   2022, 2023, 2025, 2031, 2033, 2034, 2042, 2050 ; 3
        when 2012, 2020, 2028, 2036, 2039, 2044, 2047 ; 4
        else ; 2
        end
  a = DateTime.now.getutc.to_a; delta = delta + a[2].to_f / 24 + a[1].to_f / 60 / 24 # Поправка на дробную часть дня
  lambda = 23.4406 * pi / 180; # Earth's inclination in radians
  omega = 2 * pi / 365.2564 # angular velocity of annual revolution (radians/day)
  alpha = omega * ((delta + 10) % 365) # angle in (mean) circular orbit, solar year starts 21. Dec
  beta = alpha + 0.03340560188317 * Math.sin(omega * ((delta - np) % 365)) # angle in elliptical orbit, from perigee  (radians)
  gamma = (alpha - Math.atan(Math.tan(beta) / Math.cos(lambda))) / pi # angular correction
  eot = (43200 * (gamma - gamma.round)) # equation of time in seconds
end
eot
CITIES = [
  {city: 'Magnitogorsk', lng: 59.6},
  {city: 'Moscow', lng: 37.64},
  {city: 'Novosibirsk', lng: 82.9}
]
user_city = CITIES[0]
user_date = DateTime.current
  def sun_time(city, date)
    date + (city[:lng]*4).minutes + eot.seconds
  end
sun_time(user_city, user_date)
def number_of_day_calculation(city, date)
  if date.month < 3
    mon = date.mon + 12
    year = date.year - 1
    else
    mon = date.mon
    year = date.year
  end
  number_of_day = (((mon + 1)) * 30.6).truncate  + (year * 365.25).truncate + date.day - 114
end
number_of_day_calculation(user_city, user_date)
def trunc_day_calculation(city, date)
  trunc_day = number_of_day_calculation(city, date) % 10
  if trunc_day > 4
    trunc_day -= 4
    else
    trunc_day += 6
  end
end
def brunch_day_calculation(city, date)
  brunch_day = number_of_day_calculation(city, date) % 12
  if brunch_day < 3
    brunch_day += 10
  elsif brunch_day == 0
    brunch_day = 12
    else
    brunch_day -= 2
  end
end
trunc_day_calculation(user_city, user_date)
brunch_day_calculation(user_city, user_date)
учше
xit
exit
def eot
  pi = (Math::PI) # pi
  delta = (DateTime.now.getutc.yday - 1) # (Текущий день года - 1)
  yy = DateTime.now.getutc.year
  np = case yy #The number np is the number of days from 1 January to the date of the Earth's perihelion. (http://www.astropixels.com/ephemeris/perap2001.html)
        when 1921, 1929, 1937, 1945, 1970, 1978, 1989, 1997 ; 0
        when 1923, 1924, 1926, 1932, 1934, 1935, 1940, 1942, 1943, 1946, 1948, 1951, 1953, 1954,
                   1956, 1959, 1961, 1962, 1964, 1965, 1967, 1973, 1975, 1981, 1983, 1986, 1994, 2002,
                   2005, 2008, 2013, 2016, 2021, 2029, 2043  ; 1
        when 1920, 1922, 1925, 1927, 1930, 1931, 1933, 1938, 1939, 1941, 1949, 1950, 1957, 1958,
                   1966, 1969, 1972, 1977, 1980, 1984, 1985, 1988, 1991, 1992, 1999, 2000, 2007, 2010,
                   2011, 2018, 2019, 2024, 2026, 2027, 2030, 2032, 2035, 2037, 2038, 2040, 2041, 2045,
                   2046, 2048, 2049  ; 2
        when 1928, 1936, 1944, 1947, 1952, 1955, 1960, 1963, 1968, 1971, 1974, 1976, 1979, 1982,
                   1987, 1990, 1993, 1995, 1996, 1998, 2001, 2003, 2004, 2006, 2009, 2014, 2015, 2017,
                   2022, 2023, 2025, 2031, 2033, 2034, 2042, 2050 ; 3
        when 2012, 2020, 2028, 2036, 2039, 2044, 2047 ; 4
        else ; 2
        end
  a = DateTime.now.getutc.to_a; delta = delta + a[2].to_f / 24 + a[1].to_f / 60 / 24 # Поправка на дробную часть дня
  lambda = 23.4406 * pi / 180; # Earth's inclination in radians
  omega = 2 * pi / 365.2564 # angular velocity of annual revolution (radians/day)
  alpha = omega * ((delta + 10) % 365) # angle in (mean) circular orbit, solar year starts 21. Dec
  beta = alpha + 0.03340560188317 * Math.sin(omega * ((delta - np) % 365)) # angle in elliptical orbit, from perigee  (radians)
  gamma = (alpha - Math.atan(Math.tan(beta) / Math.cos(lambda))) / pi # angular correction
  eot = (43200 * (gamma - gamma.round)) # equation of time in seconds
end
eot
CITIES = [
  {city: 'Magnitogorsk', lng: 59.6},
  {city: 'Moscow', lng: 37.64},
  {city: 'Novosibirsk', lng: 82.9}
]
user_city = CITIES[0]
user_date = DateTime.current
  def sun_time(city, date)
    date + (city[:lng]*4).minutes + eot.seconds
  end
sun_time(user_city, user_date)
def number_of_day_calculation(city, date)
  if date.month < 3
    mon = date.mon + 12
    year = date.year - 1
    else
    mon = date.mon
    year = date.year
  end
  number_of_day = (((mon + 1)) * 30.6).truncate  + (year * 365.25).truncate + date.day - 114
end
number_of_day_calculation(user_city, user_date)
def trunc_day_calculation(city, date)
  trunc_day = number_of_day_calculation(city, date) % 10
  if trunc_day > 4
    trunc_day -= 4
    else
    trunc_day += 6
  end
end
def brunch_day_calculation(city, date)
  brunch_day = number_of_day_calculation(city, date) % 12
  if brunch_day < 3
    brunch_day += 10
  elsif brunch_day == 0
    brunch_day = 12
    else
    brunch_day -= 2
  end
end
trunc_day_calculation(user_city, user_date)
brunch_day_calculation(user_city, user_date)
def guard(city, date) # таблица Стражи Часа
  case sun_time(city, date).hour
  when 19, 20 then 11
  when 21, 22 then 12
  when 23, 0 then 1
  when  1, 2 then 2
  when  3, 4 then 3
  when  5, 6 then 4
  when  7, 8 then 5
  when  9, 10 then 6
  when 11, 12 then 7
  when 13, 14 then 8
  when 15, 16 then 9
  when 17, 18 then 10
  end
end
def trunc_hour_calculation(city, date)
  trunc_hour = (guard(city, date) + ((trunc_day_calculation(city, date) - 1) * 2))%10
  if trunc_hour == 0
    trunc_hour = 10
  else
    trunc_hour
  end
  # if Date.current.leap?
  #   trunc_hour += 1
  # end
end
trunc_hour_calculation(user_city, user_date)
guard(user_city, user_date)
  def brunch_hour_calculation(city, time)
    case time.hour
    when 19..20 then 11
    when 21..22 then 12
    when 23 then 1
    when 0 then 1
    when  1..2 then 2
    when  3..4 then 3
    when  5..6 then 4
    when  7..8 then 5
    when  9..10 then 6
    when 11..12 then 7
    when 13..14 then 8
    when 15..16 then 9
    when 17..18 then 10
    end
  end
  brunch_hour_calculation(user_city, user_date)
 user_date
 user_date =  Time.now
  brunch_hour_calculation(user_city, user_date)
 Time.now.
УЧШЕ
exit
Time.parse('Mon May 18 2015 22:16:38 GMT+0600 (NOVT)')
Time.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (NOVT)')
Time.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (YEKT)')
DateTime.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (NOVT)')
Time.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (NOVT)').iso8601
Time.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (NOVT)').to_time.iso8601
Time.parse('Mon Feb 18 2015 22:16:38 GMT+0600 (NOVT)').to_time
Time.local(2020, 1,1,15).to_time.iso8601
Time.local(2020, 1,1,15).iso8601
exit
